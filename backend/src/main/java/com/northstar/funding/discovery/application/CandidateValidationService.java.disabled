package com.northstar.funding.discovery.application;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.northstar.funding.discovery.domain.CandidateStatus;
import com.northstar.funding.discovery.domain.FundingSourceCandidate;
import com.northstar.funding.discovery.infrastructure.FundingSourceCandidateRepository;

/**
 * Candidate Validation Service
 * 
 * Core business service for funding source candidate validation workflows.
 * Implements human-AI collaboration patterns with Spring Data JDBC repositories.
 * 
 * Constitutional Compliance:
 * - No ORM complexity (Spring Data JDBC)
 * - Human-AI Collaboration workflow support
 * - <500ms API performance requirement
 * - Domain-Driven Design service boundaries
 * 
 * Key Responsibilities:
 * - Candidate querying and filtering for admin review queues
 * - Status management and workflow transitions
 * - Assignment and workload balancing
 * - Duplicate detection and quality scoring
 * - Audit trail maintenance
 */
@Service
@Transactional
public class CandidateValidationService {

    private final FundingSourceCandidateRepository candidateRepository;

    public CandidateValidationService(FundingSourceCandidateRepository candidateRepository) {
        this.candidateRepository = candidateRepository;
    }

    /**
     * Primary query method for admin review dashboard
     * Used by CandidateController (contract test T013)
     * 
     * @param status Status filter (nullable - returns all statuses)
     * @param minConfidence Minimum confidence threshold (nullable - no filter)
     * @param assignedTo Assigned reviewer filter (nullable - all assignments)
     * @param pageable Pagination and sorting parameters
     * @return Paginated candidate results
     */
    @Transactional(readOnly = true)
    public Page<FundingSourceCandidate> findCandidates(
            CandidateStatus status,
            Double minConfidence,
            UUID assignedTo,
            Pageable pageable) {
        
        // Handle different filter combinations for optimal queries
        if (status != null && minConfidence != null) {
            return candidateRepository.findByStatusAndMinimumConfidence(status, minConfidence, pageable);
        }
        
        if (status != null) {
            return candidateRepository.findByStatusOrderByConfidenceScoreDesc(status, pageable);
        }
        
        if (assignedTo != null) {
            return candidateRepository.findByAssignedReviewerId(assignedTo, pageable);
        }
        
        // Advanced search for complex filter combinations
        return candidateRepository.findWithAdvancedFilters(status, minConfidence, assignedTo, null, pageable);
    }
    
    /**
     * Get candidate by ID with validation
     */
    @Transactional(readOnly = true)
    public FundingSourceCandidate getCandidateById(UUID candidateId) {
        return candidateRepository.findById(candidateId)
            .orElseThrow(() -> new CandidateNotFoundException("Candidate not found: " + candidateId));
    }
    
    /**
     * Assign candidate to reviewer for human validation
     */
    public FundingSourceCandidate assignCandidateToReviewer(UUID candidateId, UUID reviewerId) {
        FundingSourceCandidate candidate = getCandidateById(candidateId);
        
        if (candidate.getStatus() != CandidateStatus.PENDING_REVIEW) {
            throw new InvalidCandidateStateException(
                "Cannot assign candidate " + candidateId + " in status " + candidate.getStatus());
        }
        
        candidate.setAssignedReviewerId(reviewerId);
        candidate.setReviewStartedAt(LocalDateTime.now());
        candidate.setStatus(CandidateStatus.IN_REVIEW);
        candidate.setLastUpdatedAt(LocalDateTime.now());
        
        return candidateRepository.save(candidate);
    }
    
    /**
     * Start review process for candidate
     */
    public FundingSourceCandidate startReview(UUID candidateId, UUID reviewerId) {
        FundingSourceCandidate candidate = getCandidateById(candidateId);
        
        if (candidate.getAssignedReviewerId() != null && !candidate.getAssignedReviewerId().equals(reviewerId)) {
            throw new UnauthorizedReviewException(
                "Candidate " + candidateId + " is assigned to different reviewer");
        }
        
        candidate.setAssignedReviewerId(reviewerId);
        candidate.setReviewStartedAt(LocalDateTime.now());
        candidate.setStatus(CandidateStatus.IN_REVIEW);
        candidate.setLastUpdatedAt(LocalDateTime.now());
        
        return candidateRepository.save(candidate);
    }
    
    /**
     * Approve candidate for knowledge base inclusion
     */
    public FundingSourceCandidate approveCandidate(UUID candidateId, UUID reviewerId, String validationNotes) {
        FundingSourceCandidate candidate = getCandidateById(candidateId);
        validateReviewerAuthorization(candidate, reviewerId);
        
        candidate.setStatus(CandidateStatus.APPROVED);
        candidate.setValidationNotes(validationNotes);
        candidate.setLastUpdatedAt(LocalDateTime.now());
        
        return candidateRepository.save(candidate);
    }
    
    /**
     * Reject candidate with reason
     */
    public FundingSourceCandidate rejectCandidate(UUID candidateId, UUID reviewerId, String rejectionReason) {
        FundingSourceCandidate candidate = getCandidateById(candidateId);
        validateReviewerAuthorization(candidate, reviewerId);
        
        candidate.setStatus(CandidateStatus.REJECTED);
        candidate.setRejectionReason(rejectionReason);
        candidate.setLastUpdatedAt(LocalDateTime.now());
        
        return candidateRepository.save(candidate);
    }
    
    /**
     * Update candidate information during review
     */
    public FundingSourceCandidate updateCandidate(UUID candidateId, UUID reviewerId, FundingSourceCandidate updates) {
        FundingSourceCandidate candidate = getCandidateById(candidateId);
        validateReviewerAuthorization(candidate, reviewerId);
        
        // Apply business rule updates (selective field updates)
        if (updates.getOrganizationName() != null) {
            candidate.setOrganizationName(updates.getOrganizationName());
        }
        if (updates.getProgramName() != null) {
            candidate.setProgramName(updates.getProgramName());
        }
        if (updates.getDescription() != null) {
            candidate.setDescription(updates.getDescription());
        }
        if (updates.getApplicationDeadline() != null) {
            candidate.setApplicationDeadline(updates.getApplicationDeadline());
        }
        if (updates.getApplicationProcess() != null) {
            candidate.setApplicationProcess(updates.getApplicationProcess());
        }
        if (updates.getValidationNotes() != null) {
            candidate.setValidationNotes(updates.getValidationNotes());
        }
        
        candidate.setLastUpdatedAt(LocalDateTime.now());
        return candidateRepository.save(candidate);
    }
    
    /**
     * Find potential duplicates for deduplication workflow
     */
    @Transactional(readOnly = true)
    public List<FundingSourceCandidate> findPotentialDuplicates(UUID candidateId) {
        FundingSourceCandidate candidate = getCandidateById(candidateId);
        
        return candidateRepository.findPotentialDuplicates(
            candidate.getOrganizationName(),
            candidate.getProgramName(),
            candidateId
        );
    }
    
    /**
     * Mark candidate as duplicate of another
     */
    public FundingSourceCandidate markAsDuplicate(UUID candidateId, UUID masterCandidateId, UUID reviewerId) {
        FundingSourceCandidate candidate = getCandidateById(candidateId);
        validateReviewerAuthorization(candidate, reviewerId);
        
        // Verify master candidate exists
        getCandidateById(masterCandidateId);
        
        candidate.setDuplicateOfCandidateId(masterCandidateId);
        candidate.setStatus(CandidateStatus.REJECTED);
        candidate.setRejectionReason("Duplicate of candidate: " + masterCandidateId);
        candidate.setLastUpdatedAt(LocalDateTime.now());
        
        return candidateRepository.save(candidate);
    }
    
    /**
     * Get candidates assigned to specific reviewer
     */
    @Transactional(readOnly = true)
    public Page<FundingSourceCandidate> getCandidatesForReviewer(UUID reviewerId, Pageable pageable) {
        return candidateRepository.findByAssignedReviewerId(reviewerId, pageable);
    }
    
    /**
     * Get unassigned candidates for automatic assignment
     */
    @Transactional(readOnly = true)
    public List<FundingSourceCandidate> getUnassignedCandidates(int maxResults) {
        return candidateRepository.findUnassignedCandidatesForAssignment(
            Pageable.ofSize(maxResults)
        );
    }
    
    /**
     * Get stale candidates that need attention
     */
    @Transactional(readOnly = true)
    public List<FundingSourceCandidate> getStaleCandidates(int daysThreshold) {
        LocalDateTime threshold = LocalDateTime.now().minusDays(daysThreshold);
        return candidateRepository.findStaleCandidates(threshold);
    }
    
    /**
     * Get dashboard statistics
     */
    @Transactional(readOnly = true)
    public CandidateStatistics getStatistics() {
        long pending = candidateRepository.countByStatus(CandidateStatus.PENDING_REVIEW);
        long inReview = candidateRepository.countByStatus(CandidateStatus.IN_REVIEW);
        long approved = candidateRepository.countByStatus(CandidateStatus.APPROVED);
        long rejected = candidateRepository.countByStatus(CandidateStatus.REJECTED);
        
        Double avgConfidence = candidateRepository.getAverageConfidenceScore(
            LocalDateTime.now().minusDays(30)
        );
        
        return new CandidateStatistics(pending, inReview, approved, rejected, 
                                     avgConfidence != null ? avgConfidence : 0.0);
    }
    
    // Private helper methods
    
    private void validateReviewerAuthorization(FundingSourceCandidate candidate, UUID reviewerId) {
        if (candidate.getAssignedReviewerId() != null && 
            !candidate.getAssignedReviewerId().equals(reviewerId)) {
            throw new UnauthorizedReviewException(
                "Candidate " + candidate.getCandidateId() + " is not assigned to reviewer " + reviewerId);
        }
    }
    
    // Exception classes
    
    public static class CandidateNotFoundException extends RuntimeException {
        public CandidateNotFoundException(String message) {
            super(message);
        }
    }
    
    public static class InvalidCandidateStateException extends RuntimeException {
        public InvalidCandidateStateException(String message) {
            super(message);
        }
    }
    
    public static class UnauthorizedReviewException extends RuntimeException {
        public UnauthorizedReviewException(String message) {
            super(message);
        }
    }
    
    // Statistics record
    
    public static class CandidateStatistics {
        private final long pending;
        private final long inReview;
        private final long approved;
        private final long rejected;
        private final double averageConfidence;
        
        public CandidateStatistics(long pending, long inReview, long approved, long rejected, double averageConfidence) {
            this.pending = pending;
            this.inReview = inReview;
            this.approved = approved;
            this.rejected = rejected;
            this.averageConfidence = averageConfidence;
        }
        
        // Getters
        public long getPending() { return pending; }
        public long getInReview() { return inReview; }
        public long getApproved() { return approved; }
        public long getRejected() { return rejected; }
        public double getAverageConfidence() { return averageConfidence; }
        public long getTotal() { return pending + inReview + approved + rejected; }
    }
}
